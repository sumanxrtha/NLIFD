package testdemo;

import java.util.*;

/**
 * This class processed the processed List or collection 
 * That is generated by the HelperClass
 * The list is partitioned into the two list or ArrayList
 * i.e First list consists of selectList which are probably 
 * used for whereList in select statement
 * And Second consists of the whereList which are probably 
 * user for the where clause
 */

public class DivideList {
	/**
	 * The whereList list is used for building the where clause
	 * The selectList list is used for building the select clause
	 * */
	public static ArrayList<String> whereList; // W
	public static ArrayList<String> selectList; //S�
	
	/**
	 * This function takes the processed ArrayList and divide
	 * them into two list according to their dependencies returned
	 * by the dependency parser and processed with helper class 
	 */
	@SuppressWarnings("unused")
	public static void PopulateList( ArrayList<String>processedList ){
		whereList = new ArrayList<>();
		selectList = new ArrayList<>();
		boolean hasRoot = false; // flag to test if it has root 
		boolean hasSubj = false; //
		
		int size = processedList.size();
		int i = 0;
		
		while(processedList.size() > 0){
			//System.out.println("New size is: "+processedList.size());
			
			Iterator<String> itr = processedList.iterator();
			while(itr.hasNext()){
				String[] split = DivideList.Split(itr.next(),"(");
				
				//Rule 1
				if(split[0].equals("root")){
					String[] temp = DivideList.GetGovDep(split[1]);
					whereList.add(temp[1].trim());
					//System.out.println("a added: root: selecton:"+temp[1]);
					hasRoot = true;
					itr.remove();
				}
				
				//Rule 2
				else if(split[0].equals("nsubj")){
					hasSubj = true;
					String[] temp = DivideList.GetGovDep(split[1]);
					
					//sub rule i
					if(HasElement(whereList, temp[0].trim())){
						selectList.add(temp[1].trim());
						//System.out.println("1 added: nsubj: selectList:"+temp[1]);
						itr.remove();
					}
					
					//sub rule ii 
					//-- The rule is modified by not checking the hasRoot flag is either set or not set.
					else if((!HasElement(whereList, temp[0].trim())) && hasRoot == false){
						whereList.add(temp[0].trim());
						selectList.add(temp[1].trim());
						//System.out.println("2 added: nsubj: selectList:"+temp[1]+" whereList:"+temp[0]);
						itr.remove();
					}
					
					//sub rule iii
					else{
						//Do nothing it will be needed 
					}
				}
				
				//rule 3
				else if(split[0].startsWith("prep") || split[0].endsWith("obj")){
					String[] temp = DivideList.GetGovDep(split[1].trim());
					
					//sub rule i
					/**
					 * Check for aggregation if exists
					 * */
					if(SqlLibrary.ChkOperatorStatus(temp[0])){
						String test = SqlLibrary.SelWhe(temp[0]);
						if(test.equals("sel")){
							selectList.add(temp[0].trim()+"-"+temp[1].trim());
							itr.remove();
						}
						else if(test.equals("whe")){
							whereList.add(temp[0].trim()+"-"+temp[1].trim());
							itr.remove();
						}
					}
					
					
					//sub rule ii
					/**
					 * if gov E S� and if there is no table.column like gov.dep add dep to W,
					 * otherwise, also add dep to S. Remove rel from SDC
					 * */
					else if(HasElement(selectList,temp[0].trim())){
						if(!SqlLibrary.ChkStatus(temp[0].trim(), temp[1].trim())){
							whereList.add(temp[1].trim());
							//System.out.println("1.1 added: prep or obj: whereList:"+temp[1]);
						}
						else{
							//System.out.println("1.2 added: prep or obj: whereList:"+temp[1]+"selectList:"+temp[1]);
							whereList.add(temp[1].trim());
							selectList.add(temp[1].trim());
						}
						
						itr.remove();
					}
					
					//sub rule iii
					//-- The rule is modified as hasRoot and hasSubj is not checked
					//-- table.column field is not taken care 
					/**
					 * otherwise if gov not E S ,hasRoot and hasSubj are false add gov to 
					 * S . If there is not any table.column like gov.dep add dep to W,
					 * otherwise, also add dep to S�. Remove rel from SDC
					 * */
					else if(!HasElement(selectList, temp[0].trim())){
//						if(hasRoot == false && hasSubj == false){
//							whereList.add(temp[1]);
//							selectList.add(temp[0]);
//							itr.remove();
//							System.out.println("2.1 added: prep or obj: whereList:"+temp[1]+"selectList: "+temp[0]);
//						}
//						else if(!SqlLibrary.ChkStatus(temp[0], temp[1])){
//							whereList.add(temp[1]);
//							selectList.add(temp[0]);
//							System.out.println("2 added: prep or obj: whereList:"+temp[1]+"selectList: "+temp[0]);
//							itr.remove();
//						}
						//else{
							whereList.add(temp[1].trim());
							selectList.add(temp[0].trim());
							itr.remove();
						//}
						
						
					}
					
					//sub rule iv
					else{
						//Do nothing it may be needed in the recursive queries.
					}
				}
				
				//rule 4
				/**
				 * If it ends with mod, it implies that dep is a modifcator of gov, so they
				 * should be paired together: if gov E W add dep to W and if gov E S� add
				 * dep to S� and remove rel from SDC. This should be done only if
				 * dep is not a superlative (i.e. doesn't end with -st).
				 * */
				else if(split[0].endsWith("mod")){
					String[] temp = DivideList.GetGovDep(split[1]);
					//sub rule i
					if(HasElement(whereList, temp[0].trim())){
						whereList.add(temp[1].trim());
						itr.remove();
						//System.out.println("1 added: mod: whereList:"+temp[1]);
					}
					
					//sub rule ii
					else if(HasElement(selectList, temp[0].trim())){
						selectList.add(temp[1].trim());
						//System.out.println("2 added: prep or obj: selectList:"+temp[1]);
						itr.remove();
					}
					
					else{
						/**
						 * Check for aggregation functions and operators
						 * */
						String test = SqlLibrary.SelWhe(temp[1]);
						if(test.equals("sel")){
							selectList.add(temp[1].trim()+"-"+temp[0].trim());
							itr.remove();
						}
						else if(test.equals("whe")){
							whereList.add(temp[1].trim()+"-"+temp[0].trim());
							itr.remove();
						}
						
						else {
							whereList.add(temp[1].trim());
							itr.remove();
						}
					}
				}
				
				//rule 5
				else if(split[0].equals("nn")){
					String[] temp = DivideList.GetGovDep(split[1]);
					whereList.add(temp[1].trim());
					//System.out.println("1 added: nn: whereList:"+temp[1]);
					itr.remove();
				}
				
				//rule 6
				else if(split[0].startsWith("conj")){
					String[] temp = DivideList.GetGovDep(split[1]);
					selectList.add(temp[1].trim());
					//System.out.println("1 added: conj: whereList:"+temp[1]);
					itr.remove();
				}
				
				//rule 7
				else if(split[0].startsWith("dep")){
					String[] temp = DivideList.GetGovDep(split[1]);
					if(selectList.contains(temp[1].trim())){
						itr.remove();
					}
					else if(hasRoot == true && hasSubj == true){
						whereList.add(temp[1].trim());
						itr.remove();
					}
					else{
						//whereList.add(temp[1].trim());
						itr.remove();
					}
				}
			}
			i++;
			//System.out.println("New size is: "+processedList.size());
			if(i > 5)
				break;
		}
	}
	
	/**
	 * This function takes the input with out the main part of speech 
	 * e.g over-12 , jump-13)
	 * and process the list and returns the array as governor and dependents
	 * */
	public static String[] GetGovDep(String str){
		String[] GovDep = new String[2];
		
		// divide the string into governor and dependents
		String[] firstProcess = str.split(","); 
		
		// extract the governor from the firstProcess
		String[] gov = firstProcess[0].split("-"); 
		
		// extract the dependent from the firstProcess
		String[] dep = firstProcess[1].split("-");
		
		// add the extracted governor and the dependent to the array and return it 
		GovDep[0] = gov[0];
		GovDep[1] = dep[0];
		return GovDep;
	}
	
	public static String[] Split(String str,String splitter){
		String[] split = str.split("\\"+splitter);
		return split;
	}
	
	public static boolean HasElement(ArrayList<String> list, String value){
		boolean status = false;
		if(list.contains(value))
			status = true;
	
		return status;
	}
}